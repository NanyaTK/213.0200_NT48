<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8" />
<title>OpenCores USB Function Core  -竹輪雑記</title>
<meta name="description" content="ドキュメント和訳">
<link href="/ckwz/11-ckwz.css" rel="stylesheet">
<link href="/ckwz/22-cart.ico" rel="icon">
<meta name="twitter:card" content="summary">
<meta property="og:title" content="OpenCores USB Function Core -竹輪雑記">
<meta property="og:image" content="/ckwz/21-cart.png">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="/ckwz/mathjax/es5/tex-chtml.js" id="MathJax-script" defer></script><script src="/ckwz/markedjs/marked.min.js"></script></head><body><div class="content">
<header><a class="header" href="/ckwz/">竹輪雑記</a></header>
<div class="main"><div class="left"><div class="empty"></div>
<p class="update">最終更新：2025-02-10,2025-05-24(html-archive)</p>
<div class="article"><div class="articleCardMain">
<div class="articleTitle"><div class="article_title">OpenCores USB Function Core</div>
<div class="article_tag"><a class="tagurl" href="/ckwz/10-ckwz.php?tag=FPGA">FPGA</a></div></div>
<hr><div class="articleDate">投稿：2024-11-02<br>更新：2025-01-30,2025-05-24(html-archive)<br></div>
<div id="articleS" class="articleMain"></div></div></div></div></div>
<footer>&copy; 2024-2025 NanyaTK</footer>
</div><script>const art = "OpenCoresのUSB Function Coreのドキュメントを読解したときの部分和訳\n ## 1．Introducgtion\n USB2.0に完全準拠してますよ．\n \n ## 2．Architecture\n ホストインタフェースがFunction Interface にブリッジ，データメモリとコントロールレジスタはPL(Protocol Layer)に接続，PLはUTMIインタフェースに接続．UTMIはPHYに接続．\n Tang Nano 9Kに載せるからPHYは考えなくていい？わからん<br>\n <img src='images/15-001.webp' width='80%' alt='fig.1'>\n \n ### 2.1 クロック\n UTMIは接続されたPHYからのクロックで動作する．最大60MHz．残りのコアへの動機クロックも含まれる\n それ以外のすべてのブロックはホスト（＝FPGA?）からのクロックで動作．最低60MHz（USBレイテンシ要件から），理想は100MHz．\n \n ### 2.2 ホストインタフェース(FPGA側)\n WISHBONE Rev.B準拠\n \n ### 2.3 メモリインタフェースと調停機構(Arbiter)\n USBコアとインタフェースの間で割り当てをする．スタンダードなシングル同期型SRAMを用いることができる．調停機構は，その割り当て以外にデータステアリングとフロー制御も行う．\n <img src='images/15-002.webp' width='80%' alt='fig.2'>\n \n ### 2.4 SRAM\n SSRAM = Single ported Synchronous SRAM\n \n ### 2.5 Protocol Layer(PL)\n PL層は全てのUSBデータIOとコミュニケーションコントロールを担当する．\n 以下が含まれる\n <img src='images/15-003.webp' width='80%' alt='fig.3'>\n \n #### 2.5.1 DMA \\& Memory Interface\n データメモリへのインタフェース．ランダムメモリアクセスとDMA転送をサポート．misaligned dataが書き込まれなければいけないとき，プリフェッチも実行する（RMWサイクル）．\n \n #### 2.5.2 プロトコルエンジン\n すべてのUSBプロトコル処理（ハンドシェークや制御の対応）を行う．これらはSOFトークン，データ転送の確認応答（ACK，NACK，NYET），PING応答のこと．\n #### 2.5.3 パケットの組み立て\n USBで送るパケットを組み立ててoutput FIFOに配置する．\n ヘッダ組み立て -> PIDとチェックサムの挿入 -> データフィールドの設置（要求に応じて）\n #### 2.5.4 パケットの解体\n 受信した全てのパケットをデコードし，適切なブロックへ転送する．デコードにはPIDとシーケンス番号の抽出，ヘッダチェックサムの確認も含まれる．\n \n ### 2.6 UTMIインタフェース\n UTMI準拠のPHYトランシーバーへのブロック図\n <img src='images/15-005.webp' width='80%' alt='fig.5'>\n \n #### 2.6.1 インタフェースステートエンジン\n インタフェースの状態を追跡する．待機/再開モードとフルスピード/ハイスピードの切り替えを行う．内部状態マシンは動作モードの状態と切り替え状況を追跡する．\n #### 2.6.2 通信速度ネゴシエーションエンジン\n USBインタフェースと通信速度をネゴシエーションし，待機状態とリセットのハンドル（検出?）する．\n #### 2.6.3 RX & TX FIFOs\n FIFOは一時的な受信/送信データを保持する．受信FIFOはDMSが，受信したバイト列をSSRAMバッファに書き込む前に一時的にそれを保持する．送信FIFO送信されるバイト列を保持する．\n #### 2.6.4 RX & TX Bus Interface\n 受信/送信インタフェースとの適切なハンドシェークを保証する\n \n ## 3 処理(Operation)\n OperationセクションではUSB機能コントローラの動作について説明する．第一に，ホストマイクロコントローラ(ファンクション)の論理インタフェースについて解説し，第二に論理USBインタフェースについて解説する．<br>\n USBコアは一時データストレージとして使用されるローカルバッファメモリを用いる．このメモリサイズはユーザ（開発者?）が自由に定義することができる．それぞれのエンドポイントは自身専用のinput/outputバッファを持つ．異なるエンドポイント間での如何なるソフトウェアの介入は必要ない．ダブルバッファを設定することで，ソフトウェアレイテンシ要件を減らし，スループットを上昇させることができる．\n <img src='images/15-006.webp' width='80%' alt='fig.6'>\n \n ### 3.1 エンドポイント\n 最大16個のエンドポイントをサポートする．実際のエンドポイントの数はコアを合成する前に決定される．<br>\n ファンクションコントローラはエンドポイントのレジスタ：EPn_CSR，EPn_INT，EPn_BUFxに書き込むことで初期化しなければならない．ファンクションコントローラは実際の各エンドポイントの番号(EP_NO)も割り当てなければならない．エンドポイントの番号割当は物理デバイスとしてのエンドポイントを参照する．実際の論理（ホストからのエンドポイントフィールドのトークンと一致する番号）はEPn_CSRレジスタの中のEP_NOフィールドに格納されなければならない．ソフトウェアは全てのエンドポイントのトランザクションタイプがユニーク（一意）であることを確認しなければならない．\n \n #### 3.1.1 バッファポインタ\n バッファポインタはメモリ上のinput/outputデータ構造を示す．値が全て1(16x7FFFH)が指し示すのはそのバッファが割り当てられていないことである．もし，すべてのバッファが何にも割り当てられていないならば，コアはUSBホストに対してNAK確認応答を返す．<br>\n このUSBコアはファンクションマイクロコントローラとドライバソフトウェアのレイテンシ要件を減らすダブルバッファリングをサポートしている．ダブルバッファリングは全てのバッファポインタが設定されている場合に有効化される．データはバッファからRR(ラウンドロビン)方式で取出/格納される．データがエンドポイントから/エンドポイントへ送信されるとき，先頭のバッファ0が使用される．先頭バッファが空/満杯のとき，割り込みを介してファンクションコントローラに通知される．そのときファンクションコントローラはバッファ0を再代入/空にすることができる．USBコアはいまや次の動作にバッファ1を用います．2番目のバッファが満杯/空のとき，ファンクションコントローラは割り込みをし，USBコアはバッファ0を使うように戻る．バッファが割り当てられていないときはスキップする．バッファに使用済みビットが入っている場合，コアはストールを発生させ，NAK/NYET 応答を返す．<br>\n バッファ使用済みビットは，バッファが既に使用されている(この情報は割り込み元のレジスタでも提供される)ことを示す．<br>\n バッファが最大ペイロードサイズよりも大きくなる場合がある．そのようなときには，複数のパケットはバッファから/バッファへ供給される．OUTエンドポイントの為のバッファはつねに最大ペイロードサイズの倍数である必要がある．バッファの残りの容量が最大ペイロードサイズよりも小さくなった時(最大ペイロードサイズよりも小さい1つ以上のパケットが受信されたことによる)，バッファは満杯であるとみなされ，USBコアは次のバッファに切り替える．例えば，最大ペイロードサイズが512bytesのとき，バッファサイズは512,1024,1536,2048若しくはそれ以上の大きさになる．ソフトウェアはつねにバッファサイズのフィールドを確認する必要がある．バッファ全体が使用されている場合，このフィールドは0である必要がある．もしバッファサイズが0でない場合，サイズフィールドはバッファが未使用のバイト数を示す．INバッファにはこのような制限はない，コアは常に送信可能な最大のバイト数を送信する．この送信可能な最大のバイト数は常に最大ペイロードサイズかバッファに残っているサイズの小さい方となる．<br>\n <img src='images/15-007.webp' width='80%' alt='fig.7'>\n 制御エンドポイントは受信/送信が可能なため少し特殊である．そのため，制御エンドポイントの場合，バッファ0はつねにOUTバッファであり，バッファ1\n \n #### 3.1.2\n ";document.getElementById("articleS").innerHTML = marked.parse(art);</script></body>
</html>